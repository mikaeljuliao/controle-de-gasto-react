<!--

.

üìå O que √© o .map()?
. √â um m√©todo de arrays do JavaScript.
. Ele percorre cada item do array e devolve um novo array com o resultado.
. A sintaxe b√°sica √©:

array.map((item, index) => {
  return algumaCoisa;
});

. item ‚Üí o elemento atual do array.
. index ‚Üí a posi√ß√£o desse elemento no array (0, 1, 2...).
. return ‚Üí o valor que voc√™ quer colocar no novo array.

üìå Exemplo simples
const numeros = [1, 2, 3];
const dobrados = numeros.map((n) => n * 2);
console.log(dobrados); // [2, 4, 6]


üëâ Aqui o .map() passou por cada n√∫mero, multiplicou por 2 e devolveu um novo array.

üìå Exemplo no React
Quando usamos no React, normalmente queremos renderizar listas de elementos:

const frutas = ["Ma√ß√£", "Banana", "Uva"];

<ul>
  {frutas.map((fruta, index) => (
    <li key={index}>{fruta}</li>
  ))}
</ul>

Resultado na tela:
. Ma√ß√£
. Banana
. Uva

Detalhe importante:
. Sempre que usamos .map() pra renderizar, precisamos do atributo key.
. A key ajuda o React a identificar cada item da lista.
. Pode ser o index, mas o ideal √© algo √∫nico como id.




map no projeto:
no nosso projeto usamos o map com o objeto gasto
Ent√£o vamos usar .map() assim:

<ul className="list-group">
  {gastos.map((gasto) => (
    <li key={gasto.id} className="list-group-item">
      {gasto.descricao} - R$ {gasto.valor} ({gasto.tipo})
    </li>
  ))}
</ul>


üëâ Isso vai gerar um <li> para cada gasto.














üìå Parte 1 ‚Äì De onde v√™m "Receita" e "Despesa"?
Lembra l√° no formul√°rio (FormularioGasto) que temos:

<select
  className="form-select"
  value={tipo}
  onChange={(e) => setTipo(e.target.value)}
>
  <option value="Receita">Receita</option>
  <option value="Despesa">Despesa</option>
</select>

üëâ Quando voc√™ escolhe no select, o estado tipo recebe exatamente 
"Receita" ou "Despesa" (com inicial mai√∫scula, do jeito que t√° no value).

Ent√£o, cada gasto salvo no array tem essa estrutura:
js:
{
  id: 123456,
  descricao: "Aluguel",
  valor: 1000,
  tipo: "Despesa"   // <- vem direto do select
}

√â da√≠ que v√™m essas palavras.



üìå Parte 2 ‚Äì O que faz o .filter()?
. O .filter() percorre o array e retorna apenas os itens que passam na condi√ß√£o.
. Sintaxe:

array.filter((item) => condi√ß√£o)

Exemplo:
const numeros = [1, 2, 3, 4, 5];
const pares = numeros.filter((n) => n % 2 === 0);

console.log(pares); // [2, 4]


üëâ No nosso caso:
js:
gastos.filter((gasto) => gasto.tipo === "Receita")

. Isso pega s√≥ os objetos cujo tipo √© "Receita".
. Se voc√™ tivesse 5 gastos e s√≥ 2 fossem receitas, o resultado seria um array com s√≥ esses 2.



üìå Parte 3 ‚Äì O que faz o .reduce()?
. O .reduce() serve para transformar um array em um √∫nico valor.
. Ele recebe 2 par√¢metros principais:
  . acc (acumulador ‚Üí onde a soma fica guardada).
  . item (o elemento atual do array).

Sintaxe:
array.reduce((acc, item) => {
  return acc + algumaCoisa;
}, valorInicial)


Exemplo:
const numeros = [1, 2, 3];
const soma = numeros.reduce((acc, n) => acc + n, 0);

console.log(soma); // 6

üëâ O 0 no final √© o valor inicial do acumulador (come√ßa a soma a partir de 0).
Se fosse 10, a soma j√° come√ßaria em 10.





üìå Parte 4 ‚Äì Aplicando √† nossa l√≥gica:
const totalReceitas = gastos
  .filter((gasto) => gasto.tipo === "Receita")
  .reduce((acc, gasto) => acc + gasto.valor, 0);


Passo a passo:
1. filter ‚Üí pega s√≥ os gastos que s√£o receita.
2. reduce ‚Üí soma todos os valor desses gastos.
3. 0 ‚Üí soma come√ßa do zero.

Exemplo com gastos:
gastos = [
  { descricao: "Sal√°rio", valor: 3000, tipo: "Receita" },
  { descricao: "Aluguel", valor: 1200, tipo: "Despesa" },
  { descricao: "Freelance", valor: 800, tipo: "Receita" }
]

. filter ‚Üí pega s√≥ receitas:
js:
[{ descricao: "Sal√°rio", valor: 3000 }, { descricao: "Freelance", valor: 800 }]

. reduce ‚Üí soma valores:
  0 + 3000 + 800 = 3800

üëâ Resultado: totalReceitas = 3800.
Mesma l√≥gica vale para despesas.


Depois:
const saldo = totalReceitas - totalDespesas;
js:
Esse √© o saldo final.


‚úÖ Resumindo bem claro:
. "Receita" e "Despesa" v√™m do select do formul√°rio.
. filter pega s√≥ os itens com tipo correspondente.
. reduce soma todos os valores.
. 0 √© de onde a soma come√ßa.    













üìå O que √© o localStorage:
. √â um recurso do navegador que guarda dados simples em formato de texto.
. Funciona como uma caixinha de pares chave ‚Üí valor.
. Sempre que a gente salva algo, √© convertido para string.


üëâ M√©todos principais:

localStorage.setItem("chave", "valor");   // salvar
localStorage.getItem("chave");           // ler
localStorage.removeItem("chave");        // apagar 1 item
localStorage.clear();                    // apagar tudo


‚ö†Ô∏è Importante: s√≥ armazena strings. Ent√£o se queremos guardar um array ou objeto, usamos:
. JSON.stringify(objeto) para salvar.
. JSON.parse(string) para ler de volta.




üìå Como funciona no React:

No nosso projeto, queremos:
1. Quando o App inicia ‚Üí buscar no localStorage se j√° existem gastos salvos.
2. Sempre que gastos mudar ‚Üí atualizar o localStorage.




üìå Estrutura no c√≥digo:
1. Estado inicial lendo do localStorage

Normalmente a gente faria:
const [gastos, setGastos] = useState([]);


Mas isso sempre come√ßa vazio.

üëâ Ent√£o trocamos por uma fun√ß√£o inicializadora:

const [gastos, setGastos] = useState(() => {
  const dadosSalvos = localStorage.getItem("gastos"); // tenta buscar do localStorage
  return dadosSalvos ? JSON.parse(dadosSalvos) : [];  // se achar, transforma em array; se n√£o, volta []
});


Explicando:
. localStorage.getItem("gastos") ‚Üí procura algo salvo com a chave "gastos".
. Se existir, vai ser uma string tipo:
"[{\"id\":123,\"descricao\":\"Aluguel\",\"valor\":1000,\"tipo\":\"Despesa\"}]".
. JSON.parse(...) ‚Üí transforma essa string de volta num array de objetos.
. Se n√£o existir nada, usamos [] (array vazio).

Essa fun√ß√£o no useState s√≥ roda uma vez, quando o componente monta, o que evita reprocessar em todo re-render.




2. Salvando sempre que gastos mudar:
Agora precisamos atualizar o localStorage sempre que adicionarmos/removermos um gasto.
Pra isso usamos o useEffect:

useEffect(() => {
  localStorage.setItem("gastos", JSON.stringify(gastos));
}, [gastos]);


Explicando:
. useEffect(() => { ... }, [gastos]) ‚Üí esse efeito roda sempre que gastos mudar.
. localStorage.setItem("gastos", ...) ‚Üí salva no navegador.
. JSON.stringify(gastos) ‚Üí converte o array de objetos para string, porque o localStorage s√≥ aceita strings.



üìå Linha do tempo da l√≥gica:
1. O usu√°rio abre o app ‚Üí useState busca no localStorage ‚Üí se tinha dados, carrega.
2. O usu√°rio adiciona um gasto ‚Üí setGastos atualiza o estado.
3. O useEffect detecta a mudan√ßa ‚Üí salva a vers√£o atualizada no localStorage.
4. O usu√°rio fecha e abre de novo ‚Üí estado come√ßa com os dados salvos.




üìå Analogia:
Imagina que o estado (gastos) √© um caderno que tu t√° escrevendo agora.
O localStorage √© como se fosse um arm√°rio no qual tu guarda esse caderno quando fecha o app.
. JSON.stringify ‚Üí √© como tirar uma foto em texto do caderno antes de guardar no arm√°rio.
. JSON.parse ‚Üí √© como revelar essa foto em formato de caderno de novo quando tu abre.
. O useEffect ‚Üí √© o lembrete autom√°tico: ‚Äútoda vez que tu escrever algo novo no caderno, tira uma nova foto e guarda no arm√°rio‚Äù.




‚úÖ Resumindo:
. getItem ‚Üí buscar.
. setItem ‚Üí salvar.
 .JSON.stringify/parse ‚Üí convers√£o necess√°ria porque o localStorage s√≥ guarda string.
. useEffect ‚Üí garante atualiza√ß√£o autom√°tica toda vez que o estado muda.















Explica√ß√£o exclusiva do .find
Agora vamos destrinchar o m√©todo .find, do jeitinho que fiz com map, filter e reduce.

üîπ O que √©:
.find() √© um m√©todo de array do JavaScript que procura o primeiro elemento que satisfaz uma condi√ß√£o e retorna ele.



üîπ Sintaxe:
array.find((elemento) => condi√ß√£o)

. elemento ‚Üí cada item do array (um por vez).
. condi√ß√£o ‚Üí uma express√£o que precisa ser verdadeira.
. Retorno ‚Üí o primeiro elemento que bate com a condi√ß√£o, ou undefined se nenhum bater.



üîπ Exemplo simples:
const numeros = [10, 20, 30, 40];
const resultado = numeros.find((n) => n > 25);
console.log(resultado); // 30 (o primeiro n√∫mero maior que 25)



üîπ No nosso caso:
const gasto = gastos.find((gasto) => gasto.id === id);

1. .find percorre o array gastos.
2. Em cada volta, compara gasto.id com o id passado pelo bot√£o.
3. Quando encontra o gasto certo ‚Üí retorna esse objeto.
4. Guardamos ele no estado gastoEmEdicao.





‚úÖ Resumindo:
. .find retorna o primeiro elemento que satisfaz a condi√ß√£o ‚Äî aqui, o gasto com id igual ao clicado.















üìò Diferen√ßa entre aoEnviarFormulario e salvarGasto

1. Quando surgiu a fun√ß√£o aoEnviarFormulario
. No in√≠cio do projeto, o app s√≥ tinha a funcionalidade de adicionar gastos.
. Por isso, criamos uma fun√ß√£o exclusiva para esse fluxo:

function aoEnviarFormulario(event) {
  event.preventDefault();

  const novoGasto = {
    id: Date.now(),
    descricao,
    valor: parseFloat(valor),
    tipo,
  };

  aoAdicionar(novoGasto);

  setDescricao("");
  setValor("");
  setTipo("Receita");
}


üìå O que ela fazia:
. Impedia o reload do formul√°rio (event.preventDefault()).
. Criava um novo objeto gasto.
. Chamava a fun√ß√£o aoAdicionar.
. Limpava os campos do formul√°rio.

‚ö†Ô∏è Limita√ß√£o: s√≥ servia para adicionar. N√£o sabia lidar com edi√ß√£o.



2. Quando surgiu a fun√ß√£o salvarGasto:
. Depois, adicionamos a funcionalidade de editar gastos existentes.
. Agora o formul√°rio precisa ser mais inteligente:
  . Se n√£o houver gasto em edi√ß√£o ‚Üí criar um novo.
  . Se houver gasto em edi√ß√£o ‚Üí atualizar o gasto existente.

function salvarGasto(evento) {
  evento.preventDefault();

  const gastoAtualizado = {
    id: gastoSelecionado ? gastoSelecionado.id : Date.now(),
    descricao,
    valor: parseFloat(valor),
    tipo,
  };

  aoGerenciar(gastoAtualizado);

  setDescricao("");
  setValor("");
  setTipo("Receita");
}


üìå O que ela faz:
. Impede o reload do formul√°rio (evento.preventDefault()).
. Cria um objeto gasto:
  . Se tem gastoSelecionado ‚Üí usa o mesmo id (edi√ß√£o).
  . Se n√£o tem ‚Üí gera um novo id (adi√ß√£o).
. Chama aoGerenciar, que decide se vai adicionar ou atualizar.
. Limpa os campos do formul√°rio.

‚úÖ Vantagem: cobre os dois cen√°rios (adi√ß√£o e edi√ß√£o).




3. Por que precisamos s√≥ de uma fun√ß√£o agora:
. aoEnviarFormulario ‚Üí s√≥ servia para adicionar, deixou de ser √∫til quando introduzimos edi√ß√£o.
. salvarGasto ‚Üí √© mais completa, cobre os dois cen√°rios.

Se mantiv√©ssemos as duas:
. Ter√≠amos c√≥digo duplicado.
. Corr√≠amos risco de confundir qual usar no onSubmit.
. O c√≥digo ficaria menos limpo e mais dif√≠cil de manter.

üìå Conclus√£o
. No come√ßo, fazia sentido ter aoEnviarFormulario porque o app s√≥ adicionava.
. Quando passamos a ter edi√ß√£o, o fluxo de adicionar e editar p√¥de ser unificado numa s√≥ fun√ß√£o.
. salvarGasto substitui aoEnviarFormulario e √© suficiente para o formul√°rio, mantendo o c√≥digo mais limpo, claro e escal√°vel.









































modifica√ß√µes feitas: 17:20 do 17/09/2025:

3) CRUD ‚Äî como o fluxo de edi√ß√£o funciona agora (linha por linha)

1. Adicionar:
. O FormularioGasto cria um objeto gasto (com id, descricao, valor, tipo) e chama aoGerenciar(gasto).
. gerenciarGasto detecta que n√£o h√° gastoSelecionado e faz setGastos([...gastos, gasto]).
. Chama mostrarAlerta(..., "success").

2. Editar:
. O bot√£o editar na lista chama aoEditar(id) (prop ligada a abrirEdicao).
. abrirEdicao encontra o gasto e setGastoSelecionado(gasto).
. O FormularioGasto (com useEffect) pr√©-preenche os inputs com gastoSelecionado.
. Ao submeter o formul√°rio, aoGerenciar √© chamado com o objeto atualizado (mesmo id).
. gerenciarGasto detecta que h√° gastoSelecionado e substitui o item no array (map).
. Limpa gastoSelecionado (setGastoSelecionado(null)) para voltar ao modo "adicionar".
. Chama mostrarAlerta(..., "warning").

Remover:
. removerGasto(id) cria nova lista via filter e faz setGastos(novaLista).
. Chama mostrarAlerta(..., "danger").



4) Alerta ‚Äî agora um objeto com mensagem e tipo
Antes voc√™ guardava uma string; agora o estado alerta mant√©m um objeto:
{ mensagem: "Gasto adicionado", tipo: "success" }


Vantagens:
. tipo mapeia diretamente para classes Bootstrap (alert-success, alert-danger), ent√£o estilo e l√≥gica ficam juntos.
. F√°cil de estender (p.ex. duracao, acao).

Timeout seguro:
. Uso de timeoutRef para evitar ac√∫mulo de timeouts quando o usu√°rio dispara alertas r√°pidos.
. Ao criar novo alerta limpamos timeoutRef.current antigo, e ent√£o setamos um novo setTimeout.
. H√° tamb√©m cleanup no useEffect para limpar timeout se o componente desmontar.
. Isso evita comportamento estranho (alertas que somem depois de tempos antigos) e evita vazamento de timers.





















üéì Aula: Criando Gr√°ficos com Recharts no React
1. O que √© o Recharts?

. Recharts √© uma biblioteca de gr√°ficos feita para React.
. Baseada em D3.js (uma das libs mais poderosas de visualiza√ß√£o de dados), 
mas com componentes React prontos.
. Ou seja: voc√™ n√£o precisa mexer em matem√°tica nem SVG manualmente, o 
Recharts j√° abstrai isso.
. Voc√™ s√≥ precisa passar dados em forma de array de objetos + escolher 
um tipo de gr√°fico (Pizza, Barra, Linha etc).

üëâ Documenta√ß√£o oficial: https://recharts.org




2. A l√≥gica de funcionamento:
1. Criamos um array de objetos que cont√©m os dados que queremos mostrar.

const dadosGrafico = [
  { name: "Receitas", value: receitas },
  { name: "Despesas", value: despesas },
];

  . name ‚Üí nome que aparecer√° na legenda.
  . value ‚Üí valor num√©rico que ser√° representado na pizza (ou barra, etc).
2. Passamos esse array para o componente de gr√°fico do Recharts (ex.: <Pie />).
3. O Recharts renderiza automaticamente o gr√°fico, criando propor√ß√µes de acordo com os valores.



3. Estrutura do gr√°fico que fizemos:
<PieChart width={300} height={300}>
  <Pie
    data={dadosGrafico}
    dataKey="value"
    nameKey="name"
    cx="50%"
    cy="50%"
    outerRadius={100}
    label
  >
    <Cell fill="#28a745" />  {/* verde para receitas */}
    <Cell fill="#dc3545" />  {/* vermelho para despesas */}
  </Pie>
  <Tooltip />
  <Legend />
</PieChart>


Vamos destrinchar:
1. <PieChart>
. √â o container do gr√°fico de pizza.
. Define width (largura) e height (altura).
. Tudo que est√° dentro dele (como <Pie>, <Tooltip>, <Legend>) comp√µe o gr√°fico.


2. <Pie>:
. O gr√°fico em si (a pizza).
. Propriedades principais:
  . data={dadosGrafico} ‚Üí diz de onde v√™m os dados.
  . dataKey="value" ‚Üí qual campo do objeto usar para os valores (tamanho da fatia).
  . nameKey="name" ‚Üí qual campo usar para os nomes na legenda.
  . cx="50%" e cy="50%" ‚Üí centraliza√ß√£o no gr√°fico (50% do container ‚Üí centro).
  . outerRadius={100} ‚Üí tamanho do raio da pizza.
  . label ‚Üí ativa os r√≥tulos nas fatias (exibe os valores ou nomes).



3. <Cell>:
. Define a cor de cada fatia.
. Cada <Cell> corresponde a um item do array dadosGrafico.
  . O primeiro <Cell> ser√° aplicado √† primeira posi√ß√£o (Receitas).
  . O segundo <Cell> ser√° aplicado √† segunda posi√ß√£o (Despesas).

üëâ No nosso exemplo:
<Cell fill="#28a745" />  // Receitas (verde)
<Cell fill="#dc3545" />  // Despesas (vermelho)



4. <Tooltip>:
. Um bal√£o que aparece quando voc√™ passa o mouse sobre uma fatia.
. Mostra automaticamente name e value.
. N√£o precisa configurar nada extra (Recharts j√° entende).



5. <Legend>:
. Adiciona uma legenda embaixo ou ao lado do gr√°fico.
. Mostra as cores e os nomes (nameKey).
. Tamb√©m se gera automaticamente a partir do data.



4. Por que usamos GraficoGastos.jsx separado?

üëâ Por clean code e reutiliza√ß√£o:
. O App.jsx j√° cuida de muita coisa (estados, c√°lculos, localStorage).
. Deixar o gr√°fico isolado facilita manuten√ß√£o e leitura.
. Se um dia voc√™ quiser trocar o tipo de gr√°fico (pizza ‚Üí barra), s√≥ altera esse componente.



5. Diferen√ßa do "antigo" para agora:

Antes:
. Voc√™ s√≥ tinha textos num√©ricos (Saldo, Receitas, Despesas).
. Era dif√≠cil visualizar rapidamente se estava positivo ou negativo.

Agora:
. Com o gr√°fico de pizza, o usu√°rio v√™ de cara a propor√ß√£o entre receitas e despesas.
. Muito mais intuitivo e forte para portf√≥lio, porque d√° uma cara profissional ao app.




6. Resumindo (para anotar como aprendizado ‚úçÔ∏è):
1. Recharts √© uma lib de gr√°ficos pronta para React.
2. Voc√™ passa os dados como array de objetos.
3. O PieChart cont√©m o gr√°fico.
4. O Pie usa os dados e define raio, posi√ß√£o e r√≥tulos.
5. Cada Cell define uma cor para cada fatia.
6. Tooltip mostra detalhes no hover.
7. Legend gera a legenda automaticamente.
8. Mantivemos a l√≥gica limpa separando em GraficoGastos.jsx.
















üéì Aula: Gr√°fico de Barras no Recharts
1. Estrutura b√°sica

Um gr√°fico de barras no Recharts precisa de 3 componentes principais:
1. <BarChart> ‚Üí container (igual ao <PieChart> no caso anterior).
2. <Bar> ‚Üí representa as barras (receitas/despesas).
3. Eixos (<XAxis>, <YAxis>) ‚Üí para mostrar escala e categorias.



2. C√≥digo base (simples):

Suponha que temos o mesmo array:

const dadosGrafico = [
  { name: "Receitas", value: receitas },
  { name: "Despesas", value: despesas },
];


Agora montamos o gr√°fico:

<BarChart width={400} height={300} data={dadosGrafico}>
  <XAxis dataKey="name" />   {/* eixo X ‚Üí categorias (Receitas, Despesas) */}
  <YAxis />                  {/* eixo Y ‚Üí valores num√©ricos */}
  <Tooltip />                {/* tooltip no hover */}
  <Legend />                 {/* legenda */}
  <Bar dataKey="value" fill="#8884d8" />  {/* barras (cor padr√£o roxa) */}
</BarChart>



3. Explicando cada parte:
. <BarChart>
  . width e height ‚Üí tamanho do gr√°fico.
  . data={dadosGrafico} ‚Üí de onde v√™m os dados.
. <XAxis dataKey="name" />
  . O eixo X vai mostrar os nomes que colocamos no campo name (Receitas, Despesas).
. <YAxis />
  . O eixo Y mostra os n√∫meros (valores).
. <Tooltip />
  . Igual ao gr√°fico de pizza: aparece um bal√£ozinho quando passa o mouse.
. <Legend />
  . Legenda autom√°tica.
. <Bar dataKey="value" fill="#8884d8" />
  . dataKey="value" ‚Üí usa os valores num√©ricos.
  . fill="#8884d8" ‚Üí cor das barras.




4. Melhorando com cores diferentes:
Se quisermos uma cor para receitas e outra para despesas, precisamos passar duas <Bar> separadas:

<BarChart width={400} height={300} data={dadosGrafico}>
  <XAxis dataKey="name" />
  <YAxis />
  <Tooltip />
  <Legend />
  <Bar dataKey="value" fill="#28a745" name="Receitas" /> {/* verde */}
  <Bar dataKey="value" fill="#dc3545" name="Despesas" /> {/* vermelho */}
</BarChart>

‚ö†Ô∏è Mas nesse caso, como nosso data tem somente um campo (value), isso faria duas barras iguais.
üëâ A solu√ß√£o correta para diferenciar √© mudar o formato do data.



5. Estrutura de dados para barras lado a lado:

Para ter receitas e despesas em colunas diferentes, precisamos de um data assim:

const dadosGrafico = [
  { name: "Gastos", receitas: receitas, despesas: despesas }
];


Agora sim conseguimos fazer:

<BarChart width={400} height={300} data={dadosGrafico}>
  <XAxis dataKey="name" />
  <YAxis />
  <Tooltip />
  <Legend />
  <Bar dataKey="receitas" fill="#28a745" /> {/* verde */}
  <Bar dataKey="despesas" fill="#dc3545" /> {/* vermelho */}
</BarChart>


Resultado:
. Eixo X ‚Üí mostra apenas uma categoria ("Gastos").
. No gr√°fico ‚Üí aparece uma barra verde (Receitas) e uma barra 
vermelha (Despesas), lado a lado.



6. Comparando Pizza x Barra: 
. Pizza ‚Üí boa para ver propor√ß√£o (quanto % √© despesa x receita).
. Barras ‚Üí boa para ver valores absolutos (quanto cada um tem em n√∫meros, comparar lados).

üëâ Em projetos reais, muitas vezes colocamos os dois juntos: pizza para propor√ß√£o e barras para valores absolutos.




7. Anota√ß√£o para aprendizado ‚úçÔ∏è
1. O BarChart funciona parecido com o PieChart, mas precisa de eixos (XAxis, YAxis).
2. O dataKey aponta qual campo do objeto usar como valor.
3. Para ter barras lado a lado, precisamos de m√∫ltiplos campos no objeto (receitas, despesas).
4. <Tooltip> e <Legend> funcionam igual ao do PieChart.
5. O gr√°fico de barras √© ideal para compara√ß√µes diretas entre valores.

















üîé Campo de busca controlado pelo React

No React, temos dois tipos de inputs:

N√£o controlados ‚Üí o valor fica s√≥ no DOM (como no HTML puro).

Controlados ‚Üí o valor √© armazenado no estado do React (useState), e o input mostra sempre esse valor.

No seu caso, o campo de busca √© controlado.

Como funciona o ciclo:

Voc√™ digita algo no input.

O evento onChange dispara ‚Üí (e) => setBusca(e.target.value) ‚Üí isso atualiza o estado busca.

Como o value={busca}, o React pega o estado atualizado e renderiza novamente o input mostrando o novo valor.

Ou seja:
‚û°Ô∏è O usu√°rio altera ‚Üí React atualiza o estado ‚Üí Estado atualiza o valor do input.

Isso cria um "ciclo fechado" onde o React sempre sabe exatamente o que est√° no input.

‚ö° Exemplo pr√°tico:
Se voc√™ digitasse "caf√©":

O onChange captura "caf√©".

O setBusca("caf√©") guarda isso no estado.

O React re-renderiza e como value={busca}, o input exibe "caf√©".
-->