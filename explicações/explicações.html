<!--

.

📌 O que é o .map()?
. É um método de arrays do JavaScript.
. Ele percorre cada item do array e devolve um novo array com o resultado.
. A sintaxe básica é:

array.map((item, index) => {
  return algumaCoisa;
});

. item → o elemento atual do array.
. index → a posição desse elemento no array (0, 1, 2...).
. return → o valor que você quer colocar no novo array.

📌 Exemplo simples
const numeros = [1, 2, 3];
const dobrados = numeros.map((n) => n * 2);
console.log(dobrados); // [2, 4, 6]


👉 Aqui o .map() passou por cada número, multiplicou por 2 e devolveu um novo array.

📌 Exemplo no React
Quando usamos no React, normalmente queremos renderizar listas de elementos:

const frutas = ["Maçã", "Banana", "Uva"];

<ul>
  {frutas.map((fruta, index) => (
    <li key={index}>{fruta}</li>
  ))}
</ul>

Resultado na tela:
. Maçã
. Banana
. Uva

Detalhe importante:
. Sempre que usamos .map() pra renderizar, precisamos do atributo key.
. A key ajuda o React a identificar cada item da lista.
. Pode ser o index, mas o ideal é algo único como id.




map no projeto:
no nosso projeto usamos o map com o objeto gasto
Então vamos usar .map() assim:

<ul className="list-group">
  {gastos.map((gasto) => (
    <li key={gasto.id} className="list-group-item">
      {gasto.descricao} - R$ {gasto.valor} ({gasto.tipo})
    </li>
  ))}
</ul>


👉 Isso vai gerar um <li> para cada gasto.














📌 Parte 1 – De onde vêm "Receita" e "Despesa"?
Lembra lá no formulário (FormularioGasto) que temos:

<select
  className="form-select"
  value={tipo}
  onChange={(e) => setTipo(e.target.value)}
>
  <option value="Receita">Receita</option>
  <option value="Despesa">Despesa</option>
</select>

👉 Quando você escolhe no select, o estado tipo recebe exatamente 
"Receita" ou "Despesa" (com inicial maiúscula, do jeito que tá no value).

Então, cada gasto salvo no array tem essa estrutura:
js:
{
  id: 123456,
  descricao: "Aluguel",
  valor: 1000,
  tipo: "Despesa"   // <- vem direto do select
}

É daí que vêm essas palavras.



📌 Parte 2 – O que faz o .filter()?
. O .filter() percorre o array e retorna apenas os itens que passam na condição.
. Sintaxe:

array.filter((item) => condição)

Exemplo:
const numeros = [1, 2, 3, 4, 5];
const pares = numeros.filter((n) => n % 2 === 0);

console.log(pares); // [2, 4]


👉 No nosso caso:
js:
gastos.filter((gasto) => gasto.tipo === "Receita")

. Isso pega só os objetos cujo tipo é "Receita".
. Se você tivesse 5 gastos e só 2 fossem receitas, o resultado seria um array com só esses 2.



📌 Parte 3 – O que faz o .reduce()?
. O .reduce() serve para transformar um array em um único valor.
. Ele recebe 2 parâmetros principais:
  . acc (acumulador → onde a soma fica guardada).
  . item (o elemento atual do array).

Sintaxe:
array.reduce((acc, item) => {
  return acc + algumaCoisa;
}, valorInicial)


Exemplo:
const numeros = [1, 2, 3];
const soma = numeros.reduce((acc, n) => acc + n, 0);

console.log(soma); // 6

👉 O 0 no final é o valor inicial do acumulador (começa a soma a partir de 0).
Se fosse 10, a soma já começaria em 10.





📌 Parte 4 – Aplicando à nossa lógica:
const totalReceitas = gastos
  .filter((gasto) => gasto.tipo === "Receita")
  .reduce((acc, gasto) => acc + gasto.valor, 0);


Passo a passo:
1. filter → pega só os gastos que são receita.
2. reduce → soma todos os valor desses gastos.
3. 0 → soma começa do zero.

Exemplo com gastos:
gastos = [
  { descricao: "Salário", valor: 3000, tipo: "Receita" },
  { descricao: "Aluguel", valor: 1200, tipo: "Despesa" },
  { descricao: "Freelance", valor: 800, tipo: "Receita" }
]

. filter → pega só receitas:
js:
[{ descricao: "Salário", valor: 3000 }, { descricao: "Freelance", valor: 800 }]

. reduce → soma valores:
  0 + 3000 + 800 = 3800

👉 Resultado: totalReceitas = 3800.
Mesma lógica vale para despesas.


Depois:
const saldo = totalReceitas - totalDespesas;
js:
Esse é o saldo final.


✅ Resumindo bem claro:
. "Receita" e "Despesa" vêm do select do formulário.
. filter pega só os itens com tipo correspondente.
. reduce soma todos os valores.
. 0 é de onde a soma começa.    













📌 O que é o localStorage:
. É um recurso do navegador que guarda dados simples em formato de texto.
. Funciona como uma caixinha de pares chave → valor.
. Sempre que a gente salva algo, é convertido para string.


👉 Métodos principais:

localStorage.setItem("chave", "valor");   // salvar
localStorage.getItem("chave");           // ler
localStorage.removeItem("chave");        // apagar 1 item
localStorage.clear();                    // apagar tudo


⚠️ Importante: só armazena strings. Então se queremos guardar um array ou objeto, usamos:
. JSON.stringify(objeto) para salvar.
. JSON.parse(string) para ler de volta.




📌 Como funciona no React:

No nosso projeto, queremos:
1. Quando o App inicia → buscar no localStorage se já existem gastos salvos.
2. Sempre que gastos mudar → atualizar o localStorage.




📌 Estrutura no código:
1. Estado inicial lendo do localStorage

Normalmente a gente faria:
const [gastos, setGastos] = useState([]);


Mas isso sempre começa vazio.

👉 Então trocamos por uma função inicializadora:

const [gastos, setGastos] = useState(() => {
  const dadosSalvos = localStorage.getItem("gastos"); // tenta buscar do localStorage
  return dadosSalvos ? JSON.parse(dadosSalvos) : [];  // se achar, transforma em array; se não, volta []
});


Explicando:
. localStorage.getItem("gastos") → procura algo salvo com a chave "gastos".
. Se existir, vai ser uma string tipo:
"[{\"id\":123,\"descricao\":\"Aluguel\",\"valor\":1000,\"tipo\":\"Despesa\"}]".
. JSON.parse(...) → transforma essa string de volta num array de objetos.
. Se não existir nada, usamos [] (array vazio).

Essa função no useState só roda uma vez, quando o componente monta, o que evita reprocessar em todo re-render.




2. Salvando sempre que gastos mudar:
Agora precisamos atualizar o localStorage sempre que adicionarmos/removermos um gasto.
Pra isso usamos o useEffect:

useEffect(() => {
  localStorage.setItem("gastos", JSON.stringify(gastos));
}, [gastos]);


Explicando:
. useEffect(() => { ... }, [gastos]) → esse efeito roda sempre que gastos mudar.
. localStorage.setItem("gastos", ...) → salva no navegador.
. JSON.stringify(gastos) → converte o array de objetos para string, porque o localStorage só aceita strings.



📌 Linha do tempo da lógica:
1. O usuário abre o app → useState busca no localStorage → se tinha dados, carrega.
2. O usuário adiciona um gasto → setGastos atualiza o estado.
3. O useEffect detecta a mudança → salva a versão atualizada no localStorage.
4. O usuário fecha e abre de novo → estado começa com os dados salvos.




📌 Analogia:
Imagina que o estado (gastos) é um caderno que tu tá escrevendo agora.
O localStorage é como se fosse um armário no qual tu guarda esse caderno quando fecha o app.
. JSON.stringify → é como tirar uma foto em texto do caderno antes de guardar no armário.
. JSON.parse → é como revelar essa foto em formato de caderno de novo quando tu abre.
. O useEffect → é o lembrete automático: “toda vez que tu escrever algo novo no caderno, tira uma nova foto e guarda no armário”.




✅ Resumindo:
. getItem → buscar.
. setItem → salvar.
 .JSON.stringify/parse → conversão necessária porque o localStorage só guarda string.
. useEffect → garante atualização automática toda vez que o estado muda.















Explicação exclusiva do .find
Agora vamos destrinchar o método .find, do jeitinho que fiz com map, filter e reduce.

🔹 O que é:
.find() é um método de array do JavaScript que procura o primeiro elemento que satisfaz uma condição e retorna ele.



🔹 Sintaxe:
array.find((elemento) => condição)

. elemento → cada item do array (um por vez).
. condição → uma expressão que precisa ser verdadeira.
. Retorno → o primeiro elemento que bate com a condição, ou undefined se nenhum bater.



🔹 Exemplo simples:
const numeros = [10, 20, 30, 40];
const resultado = numeros.find((n) => n > 25);
console.log(resultado); // 30 (o primeiro número maior que 25)



🔹 No nosso caso:
const gasto = gastos.find((gasto) => gasto.id === id);

1. .find percorre o array gastos.
2. Em cada volta, compara gasto.id com o id passado pelo botão.
3. Quando encontra o gasto certo → retorna esse objeto.
4. Guardamos ele no estado gastoEmEdicao.





✅ Resumindo:
. .find retorna o primeiro elemento que satisfaz a condição — aqui, o gasto com id igual ao clicado.















📘 Diferença entre aoEnviarFormulario e salvarGasto

1. Quando surgiu a função aoEnviarFormulario
. No início do projeto, o app só tinha a funcionalidade de adicionar gastos.
. Por isso, criamos uma função exclusiva para esse fluxo:

function aoEnviarFormulario(event) {
  event.preventDefault();

  const novoGasto = {
    id: Date.now(),
    descricao,
    valor: parseFloat(valor),
    tipo,
  };

  aoAdicionar(novoGasto);

  setDescricao("");
  setValor("");
  setTipo("Receita");
}


📌 O que ela fazia:
. Impedia o reload do formulário (event.preventDefault()).
. Criava um novo objeto gasto.
. Chamava a função aoAdicionar.
. Limpava os campos do formulário.

⚠️ Limitação: só servia para adicionar. Não sabia lidar com edição.



2. Quando surgiu a função salvarGasto:
. Depois, adicionamos a funcionalidade de editar gastos existentes.
. Agora o formulário precisa ser mais inteligente:
  . Se não houver gasto em edição → criar um novo.
  . Se houver gasto em edição → atualizar o gasto existente.

function salvarGasto(evento) {
  evento.preventDefault();

  const gastoAtualizado = {
    id: gastoSelecionado ? gastoSelecionado.id : Date.now(),
    descricao,
    valor: parseFloat(valor),
    tipo,
  };

  aoGerenciar(gastoAtualizado);

  setDescricao("");
  setValor("");
  setTipo("Receita");
}


📌 O que ela faz:
. Impede o reload do formulário (evento.preventDefault()).
. Cria um objeto gasto:
  . Se tem gastoSelecionado → usa o mesmo id (edição).
  . Se não tem → gera um novo id (adição).
. Chama aoGerenciar, que decide se vai adicionar ou atualizar.
. Limpa os campos do formulário.

✅ Vantagem: cobre os dois cenários (adição e edição).




3. Por que precisamos só de uma função agora:
. aoEnviarFormulario → só servia para adicionar, deixou de ser útil quando introduzimos edição.
. salvarGasto → é mais completa, cobre os dois cenários.

Se mantivéssemos as duas:
. Teríamos código duplicado.
. Corríamos risco de confundir qual usar no onSubmit.
. O código ficaria menos limpo e mais difícil de manter.

📌 Conclusão
. No começo, fazia sentido ter aoEnviarFormulario porque o app só adicionava.
. Quando passamos a ter edição, o fluxo de adicionar e editar pôde ser unificado numa só função.
. salvarGasto substitui aoEnviarFormulario e é suficiente para o formulário, mantendo o código mais limpo, claro e escalável.









































modificações feitas: 17:20 do 17/09/2025:

3) CRUD — como o fluxo de edição funciona agora (linha por linha)

1. Adicionar:
. O FormularioGasto cria um objeto gasto (com id, descricao, valor, tipo) e chama aoGerenciar(gasto).
. gerenciarGasto detecta que não há gastoSelecionado e faz setGastos([...gastos, gasto]).
. Chama mostrarAlerta(..., "success").

2. Editar:
. O botão editar na lista chama aoEditar(id) (prop ligada a abrirEdicao).
. abrirEdicao encontra o gasto e setGastoSelecionado(gasto).
. O FormularioGasto (com useEffect) pré-preenche os inputs com gastoSelecionado.
. Ao submeter o formulário, aoGerenciar é chamado com o objeto atualizado (mesmo id).
. gerenciarGasto detecta que há gastoSelecionado e substitui o item no array (map).
. Limpa gastoSelecionado (setGastoSelecionado(null)) para voltar ao modo "adicionar".
. Chama mostrarAlerta(..., "warning").

Remover:
. removerGasto(id) cria nova lista via filter e faz setGastos(novaLista).
. Chama mostrarAlerta(..., "danger").



4) Alerta — agora um objeto com mensagem e tipo
Antes você guardava uma string; agora o estado alerta mantém um objeto:
{ mensagem: "Gasto adicionado", tipo: "success" }


Vantagens:
. tipo mapeia diretamente para classes Bootstrap (alert-success, alert-danger), então estilo e lógica ficam juntos.
. Fácil de estender (p.ex. duracao, acao).

Timeout seguro:
. Uso de timeoutRef para evitar acúmulo de timeouts quando o usuário dispara alertas rápidos.
. Ao criar novo alerta limpamos timeoutRef.current antigo, e então setamos um novo setTimeout.
. Há também cleanup no useEffect para limpar timeout se o componente desmontar.
. Isso evita comportamento estranho (alertas que somem depois de tempos antigos) e evita vazamento de timers.





















🎓 Aula: Criando Gráficos com Recharts no React
1. O que é o Recharts?

. Recharts é uma biblioteca de gráficos feita para React.
. Baseada em D3.js (uma das libs mais poderosas de visualização de dados), 
mas com componentes React prontos.
. Ou seja: você não precisa mexer em matemática nem SVG manualmente, o 
Recharts já abstrai isso.
. Você só precisa passar dados em forma de array de objetos + escolher 
um tipo de gráfico (Pizza, Barra, Linha etc).

👉 Documentação oficial: https://recharts.org




2. A lógica de funcionamento:
1. Criamos um array de objetos que contém os dados que queremos mostrar.

const dadosGrafico = [
  { name: "Receitas", value: receitas },
  { name: "Despesas", value: despesas },
];

  . name → nome que aparecerá na legenda.
  . value → valor numérico que será representado na pizza (ou barra, etc).
2. Passamos esse array para o componente de gráfico do Recharts (ex.: <Pie />).
3. O Recharts renderiza automaticamente o gráfico, criando proporções de acordo com os valores.



3. Estrutura do gráfico que fizemos:
<PieChart width={300} height={300}>
  <Pie
    data={dadosGrafico}
    dataKey="value"
    nameKey="name"
    cx="50%"
    cy="50%"
    outerRadius={100}
    label
  >
    <Cell fill="#28a745" />  {/* verde para receitas */}
    <Cell fill="#dc3545" />  {/* vermelho para despesas */}
  </Pie>
  <Tooltip />
  <Legend />
</PieChart>


Vamos destrinchar:
1. <PieChart>
. É o container do gráfico de pizza.
. Define width (largura) e height (altura).
. Tudo que está dentro dele (como <Pie>, <Tooltip>, <Legend>) compõe o gráfico.


2. <Pie>:
. O gráfico em si (a pizza).
. Propriedades principais:
  . data={dadosGrafico} → diz de onde vêm os dados.
  . dataKey="value" → qual campo do objeto usar para os valores (tamanho da fatia).
  . nameKey="name" → qual campo usar para os nomes na legenda.
  . cx="50%" e cy="50%" → centralização no gráfico (50% do container → centro).
  . outerRadius={100} → tamanho do raio da pizza.
  . label → ativa os rótulos nas fatias (exibe os valores ou nomes).



3. <Cell>:
. Define a cor de cada fatia.
. Cada <Cell> corresponde a um item do array dadosGrafico.
  . O primeiro <Cell> será aplicado à primeira posição (Receitas).
  . O segundo <Cell> será aplicado à segunda posição (Despesas).

👉 No nosso exemplo:
<Cell fill="#28a745" />  // Receitas (verde)
<Cell fill="#dc3545" />  // Despesas (vermelho)



4. <Tooltip>:
. Um balão que aparece quando você passa o mouse sobre uma fatia.
. Mostra automaticamente name e value.
. Não precisa configurar nada extra (Recharts já entende).



5. <Legend>:
. Adiciona uma legenda embaixo ou ao lado do gráfico.
. Mostra as cores e os nomes (nameKey).
. Também se gera automaticamente a partir do data.



4. Por que usamos GraficoGastos.jsx separado?

👉 Por clean code e reutilização:
. O App.jsx já cuida de muita coisa (estados, cálculos, localStorage).
. Deixar o gráfico isolado facilita manutenção e leitura.
. Se um dia você quiser trocar o tipo de gráfico (pizza → barra), só altera esse componente.



5. Diferença do "antigo" para agora:

Antes:
. Você só tinha textos numéricos (Saldo, Receitas, Despesas).
. Era difícil visualizar rapidamente se estava positivo ou negativo.

Agora:
. Com o gráfico de pizza, o usuário vê de cara a proporção entre receitas e despesas.
. Muito mais intuitivo e forte para portfólio, porque dá uma cara profissional ao app.




6. Resumindo (para anotar como aprendizado ✍️):
1. Recharts é uma lib de gráficos pronta para React.
2. Você passa os dados como array de objetos.
3. O PieChart contém o gráfico.
4. O Pie usa os dados e define raio, posição e rótulos.
5. Cada Cell define uma cor para cada fatia.
6. Tooltip mostra detalhes no hover.
7. Legend gera a legenda automaticamente.
8. Mantivemos a lógica limpa separando em GraficoGastos.jsx.
















🎓 Aula: Gráfico de Barras no Recharts
1. Estrutura básica

Um gráfico de barras no Recharts precisa de 3 componentes principais:
1. <BarChart> → container (igual ao <PieChart> no caso anterior).
2. <Bar> → representa as barras (receitas/despesas).
3. Eixos (<XAxis>, <YAxis>) → para mostrar escala e categorias.



2. Código base (simples):

Suponha que temos o mesmo array:

const dadosGrafico = [
  { name: "Receitas", value: receitas },
  { name: "Despesas", value: despesas },
];


Agora montamos o gráfico:

<BarChart width={400} height={300} data={dadosGrafico}>
  <XAxis dataKey="name" />   {/* eixo X → categorias (Receitas, Despesas) */}
  <YAxis />                  {/* eixo Y → valores numéricos */}
  <Tooltip />                {/* tooltip no hover */}
  <Legend />                 {/* legenda */}
  <Bar dataKey="value" fill="#8884d8" />  {/* barras (cor padrão roxa) */}
</BarChart>



3. Explicando cada parte:
. <BarChart>
  . width e height → tamanho do gráfico.
  . data={dadosGrafico} → de onde vêm os dados.
. <XAxis dataKey="name" />
  . O eixo X vai mostrar os nomes que colocamos no campo name (Receitas, Despesas).
. <YAxis />
  . O eixo Y mostra os números (valores).
. <Tooltip />
  . Igual ao gráfico de pizza: aparece um balãozinho quando passa o mouse.
. <Legend />
  . Legenda automática.
. <Bar dataKey="value" fill="#8884d8" />
  . dataKey="value" → usa os valores numéricos.
  . fill="#8884d8" → cor das barras.




4. Melhorando com cores diferentes:
Se quisermos uma cor para receitas e outra para despesas, precisamos passar duas <Bar> separadas:

<BarChart width={400} height={300} data={dadosGrafico}>
  <XAxis dataKey="name" />
  <YAxis />
  <Tooltip />
  <Legend />
  <Bar dataKey="value" fill="#28a745" name="Receitas" /> {/* verde */}
  <Bar dataKey="value" fill="#dc3545" name="Despesas" /> {/* vermelho */}
</BarChart>

⚠️ Mas nesse caso, como nosso data tem somente um campo (value), isso faria duas barras iguais.
👉 A solução correta para diferenciar é mudar o formato do data.



5. Estrutura de dados para barras lado a lado:

Para ter receitas e despesas em colunas diferentes, precisamos de um data assim:

const dadosGrafico = [
  { name: "Gastos", receitas: receitas, despesas: despesas }
];


Agora sim conseguimos fazer:

<BarChart width={400} height={300} data={dadosGrafico}>
  <XAxis dataKey="name" />
  <YAxis />
  <Tooltip />
  <Legend />
  <Bar dataKey="receitas" fill="#28a745" /> {/* verde */}
  <Bar dataKey="despesas" fill="#dc3545" /> {/* vermelho */}
</BarChart>


Resultado:
. Eixo X → mostra apenas uma categoria ("Gastos").
. No gráfico → aparece uma barra verde (Receitas) e uma barra 
vermelha (Despesas), lado a lado.



6. Comparando Pizza x Barra: 
. Pizza → boa para ver proporção (quanto % é despesa x receita).
. Barras → boa para ver valores absolutos (quanto cada um tem em números, comparar lados).

👉 Em projetos reais, muitas vezes colocamos os dois juntos: pizza para proporção e barras para valores absolutos.




7. Anotação para aprendizado ✍️
1. O BarChart funciona parecido com o PieChart, mas precisa de eixos (XAxis, YAxis).
2. O dataKey aponta qual campo do objeto usar como valor.
3. Para ter barras lado a lado, precisamos de múltiplos campos no objeto (receitas, despesas).
4. <Tooltip> e <Legend> funcionam igual ao do PieChart.
5. O gráfico de barras é ideal para comparações diretas entre valores.

















🔎 Campo de busca controlado pelo React

No React, temos dois tipos de inputs:

Não controlados → o valor fica só no DOM (como no HTML puro).

Controlados → o valor é armazenado no estado do React (useState), e o input mostra sempre esse valor.

No seu caso, o campo de busca é controlado.

Como funciona o ciclo:

Você digita algo no input.

O evento onChange dispara → (e) => setBusca(e.target.value) → isso atualiza o estado busca.

Como o value={busca}, o React pega o estado atualizado e renderiza novamente o input mostrando o novo valor.

Ou seja:
➡️ O usuário altera → React atualiza o estado → Estado atualiza o valor do input.

Isso cria um "ciclo fechado" onde o React sempre sabe exatamente o que está no input.

⚡ Exemplo prático:
Se você digitasse "café":

O onChange captura "café".

O setBusca("café") guarda isso no estado.

O React re-renderiza e como value={busca}, o input exibe "café".
-->