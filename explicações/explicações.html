<!--

.

ğŸ“Œ O que Ã© o .map()?
. Ã‰ um mÃ©todo de arrays do JavaScript.
. Ele percorre cada item do array e devolve um novo array com o resultado.
. A sintaxe bÃ¡sica Ã©:

array.map((item, index) => {
  return algumaCoisa;
});

. item â†’ o elemento atual do array.
. index â†’ a posiÃ§Ã£o desse elemento no array (0, 1, 2...).
. return â†’ o valor que vocÃª quer colocar no novo array.

ğŸ“Œ Exemplo simples
const numeros = [1, 2, 3];
const dobrados = numeros.map((n) => n * 2);
console.log(dobrados); // [2, 4, 6]


ğŸ‘‰ Aqui o .map() passou por cada nÃºmero, multiplicou por 2 e devolveu um novo array.

ğŸ“Œ Exemplo no React
Quando usamos no React, normalmente queremos renderizar listas de elementos:

const frutas = ["MaÃ§Ã£", "Banana", "Uva"];

<ul>
  {frutas.map((fruta, index) => (
    <li key={index}>{fruta}</li>
  ))}
</ul>

Resultado na tela:
. MaÃ§Ã£
. Banana
. Uva

Detalhe importante:
. Sempre que usamos .map() pra renderizar, precisamos do atributo key.
. A key ajuda o React a identificar cada item da lista.
. Pode ser o index, mas o ideal Ã© algo Ãºnico como id.




map no projeto:
no nosso projeto usamos o map com o objeto gasto
EntÃ£o vamos usar .map() assim:

<ul className="list-group">
  {gastos.map((gasto) => (
    <li key={gasto.id} className="list-group-item">
      {gasto.descricao} - R$ {gasto.valor} ({gasto.tipo})
    </li>
  ))}
</ul>


ğŸ‘‰ Isso vai gerar um <li> para cada gasto.














ğŸ“Œ Parte 1 â€“ De onde vÃªm "Receita" e "Despesa"?
Lembra lÃ¡ no formulÃ¡rio (FormularioGasto) que temos:

<select
  className="form-select"
  value={tipo}
  onChange={(e) => setTipo(e.target.value)}
>
  <option value="Receita">Receita</option>
  <option value="Despesa">Despesa</option>
</select>

ğŸ‘‰ Quando vocÃª escolhe no select, o estado tipo recebe exatamente 
"Receita" ou "Despesa" (com inicial maiÃºscula, do jeito que tÃ¡ no value).

EntÃ£o, cada gasto salvo no array tem essa estrutura:
js:
{
  id: 123456,
  descricao: "Aluguel",
  valor: 1000,
  tipo: "Despesa"   // <- vem direto do select
}

Ã‰ daÃ­ que vÃªm essas palavras.



ğŸ“Œ Parte 2 â€“ O que faz o .filter()?
. O .filter() percorre o array e retorna apenas os itens que passam na condiÃ§Ã£o.
. Sintaxe:

array.filter((item) => condiÃ§Ã£o)

Exemplo:
const numeros = [1, 2, 3, 4, 5];
const pares = numeros.filter((n) => n % 2 === 0);

console.log(pares); // [2, 4]


ğŸ‘‰ No nosso caso:
js:
gastos.filter((gasto) => gasto.tipo === "Receita")

. Isso pega sÃ³ os objetos cujo tipo Ã© "Receita".
. Se vocÃª tivesse 5 gastos e sÃ³ 2 fossem receitas, o resultado seria um array com sÃ³ esses 2.



ğŸ“Œ Parte 3 â€“ O que faz o .reduce()?
. O .reduce() serve para transformar um array em um Ãºnico valor.
. Ele recebe 2 parÃ¢metros principais:
  . acc (acumulador â†’ onde a soma fica guardada).
  . item (o elemento atual do array).

Sintaxe:
array.reduce((acc, item) => {
  return acc + algumaCoisa;
}, valorInicial)


Exemplo:
const numeros = [1, 2, 3];
const soma = numeros.reduce((acc, n) => acc + n, 0);

console.log(soma); // 6

ğŸ‘‰ O 0 no final Ã© o valor inicial do acumulador (comeÃ§a a soma a partir de 0).
Se fosse 10, a soma jÃ¡ comeÃ§aria em 10.





ğŸ“Œ Parte 4 â€“ Aplicando Ã  nossa lÃ³gica:
const totalReceitas = gastos
  .filter((gasto) => gasto.tipo === "Receita")
  .reduce((acc, gasto) => acc + gasto.valor, 0);


Passo a passo:
1. filter â†’ pega sÃ³ os gastos que sÃ£o receita.
2. reduce â†’ soma todos os valor desses gastos.
3. 0 â†’ soma comeÃ§a do zero.

Exemplo com gastos:
gastos = [
  { descricao: "SalÃ¡rio", valor: 3000, tipo: "Receita" },
  { descricao: "Aluguel", valor: 1200, tipo: "Despesa" },
  { descricao: "Freelance", valor: 800, tipo: "Receita" }
]

. filter â†’ pega sÃ³ receitas:
js:
[{ descricao: "SalÃ¡rio", valor: 3000 }, { descricao: "Freelance", valor: 800 }]

. reduce â†’ soma valores:
  0 + 3000 + 800 = 3800

ğŸ‘‰ Resultado: totalReceitas = 3800.
Mesma lÃ³gica vale para despesas.


Depois:
const saldo = totalReceitas - totalDespesas;
js:
Esse Ã© o saldo final.


âœ… Resumindo bem claro:
. "Receita" e "Despesa" vÃªm do select do formulÃ¡rio.
. filter pega sÃ³ os itens com tipo correspondente.
. reduce soma todos os valores.
. 0 Ã© de onde a soma comeÃ§a.    













ğŸ“Œ O que Ã© o localStorage:
. Ã‰ um recurso do navegador que guarda dados simples em formato de texto.
. Funciona como uma caixinha de pares chave â†’ valor.
. Sempre que a gente salva algo, Ã© convertido para string.


ğŸ‘‰ MÃ©todos principais:

localStorage.setItem("chave", "valor");   // salvar
localStorage.getItem("chave");           // ler
localStorage.removeItem("chave");        // apagar 1 item
localStorage.clear();                    // apagar tudo


âš ï¸ Importante: sÃ³ armazena strings. EntÃ£o se queremos guardar um array ou objeto, usamos:
. JSON.stringify(objeto) para salvar.
. JSON.parse(string) para ler de volta.




ğŸ“Œ Como funciona no React:

No nosso projeto, queremos:
1. Quando o App inicia â†’ buscar no localStorage se jÃ¡ existem gastos salvos.
2. Sempre que gastos mudar â†’ atualizar o localStorage.




ğŸ“Œ Estrutura no cÃ³digo:
1. Estado inicial lendo do localStorage

Normalmente a gente faria:
const [gastos, setGastos] = useState([]);


Mas isso sempre comeÃ§a vazio.

ğŸ‘‰ EntÃ£o trocamos por uma funÃ§Ã£o inicializadora:

const [gastos, setGastos] = useState(() => {
  const dadosSalvos = localStorage.getItem("gastos"); // tenta buscar do localStorage
  return dadosSalvos ? JSON.parse(dadosSalvos) : [];  // se achar, transforma em array; se nÃ£o, volta []
});


Explicando:
. localStorage.getItem("gastos") â†’ procura algo salvo com a chave "gastos".
. Se existir, vai ser uma string tipo:
"[{\"id\":123,\"descricao\":\"Aluguel\",\"valor\":1000,\"tipo\":\"Despesa\"}]".
. JSON.parse(...) â†’ transforma essa string de volta num array de objetos.
. Se nÃ£o existir nada, usamos [] (array vazio).

Essa funÃ§Ã£o no useState sÃ³ roda uma vez, quando o componente monta, o que evita reprocessar em todo re-render.




2. Salvando sempre que gastos mudar:
Agora precisamos atualizar o localStorage sempre que adicionarmos/removermos um gasto.
Pra isso usamos o useEffect:

useEffect(() => {
  localStorage.setItem("gastos", JSON.stringify(gastos));
}, [gastos]);


Explicando:
. useEffect(() => { ... }, [gastos]) â†’ esse efeito roda sempre que gastos mudar.
. localStorage.setItem("gastos", ...) â†’ salva no navegador.
. JSON.stringify(gastos) â†’ converte o array de objetos para string, porque o localStorage sÃ³ aceita strings.



ğŸ“Œ Linha do tempo da lÃ³gica:
1. O usuÃ¡rio abre o app â†’ useState busca no localStorage â†’ se tinha dados, carrega.
2. O usuÃ¡rio adiciona um gasto â†’ setGastos atualiza o estado.
3. O useEffect detecta a mudanÃ§a â†’ salva a versÃ£o atualizada no localStorage.
4. O usuÃ¡rio fecha e abre de novo â†’ estado comeÃ§a com os dados salvos.




ğŸ“Œ Analogia:
Imagina que o estado (gastos) Ã© um caderno que tu tÃ¡ escrevendo agora.
O localStorage Ã© como se fosse um armÃ¡rio no qual tu guarda esse caderno quando fecha o app.
. JSON.stringify â†’ Ã© como tirar uma foto em texto do caderno antes de guardar no armÃ¡rio.
. JSON.parse â†’ Ã© como revelar essa foto em formato de caderno de novo quando tu abre.
. O useEffect â†’ Ã© o lembrete automÃ¡tico: â€œtoda vez que tu escrever algo novo no caderno, tira uma nova foto e guarda no armÃ¡rioâ€.




âœ… Resumindo:
. getItem â†’ buscar.
. setItem â†’ salvar.
 .JSON.stringify/parse â†’ conversÃ£o necessÃ¡ria porque o localStorage sÃ³ guarda string.
. useEffect â†’ garante atualizaÃ§Ã£o automÃ¡tica toda vez que o estado muda.















ExplicaÃ§Ã£o exclusiva do .find
Agora vamos destrinchar o mÃ©todo .find, do jeitinho que fiz com map, filter e reduce.

ğŸ”¹ O que Ã©:
.find() Ã© um mÃ©todo de array do JavaScript que procura o primeiro elemento que satisfaz uma condiÃ§Ã£o e retorna ele.



ğŸ”¹ Sintaxe:
array.find((elemento) => condiÃ§Ã£o)

. elemento â†’ cada item do array (um por vez).
. condiÃ§Ã£o â†’ uma expressÃ£o que precisa ser verdadeira.
. Retorno â†’ o primeiro elemento que bate com a condiÃ§Ã£o, ou undefined se nenhum bater.



ğŸ”¹ Exemplo simples:
const numeros = [10, 20, 30, 40];
const resultado = numeros.find((n) => n > 25);
console.log(resultado); // 30 (o primeiro nÃºmero maior que 25)



ğŸ”¹ No nosso caso:
const gasto = gastos.find((gasto) => gasto.id === id);

1. .find percorre o array gastos.
2. Em cada volta, compara gasto.id com o id passado pelo botÃ£o.
3. Quando encontra o gasto certo â†’ retorna esse objeto.
4. Guardamos ele no estado gastoEmEdicao.





âœ… Resumindo:
. .find retorna o primeiro elemento que satisfaz a condiÃ§Ã£o â€” aqui, o gasto com id igual ao clicado.















ğŸ“˜ DiferenÃ§a entre aoEnviarFormulario e salvarGasto

1. Quando surgiu a funÃ§Ã£o aoEnviarFormulario
. No inÃ­cio do projeto, o app sÃ³ tinha a funcionalidade de adicionar gastos.
. Por isso, criamos uma funÃ§Ã£o exclusiva para esse fluxo:

function aoEnviarFormulario(event) {
  event.preventDefault();

  const novoGasto = {
    id: Date.now(),
    descricao,
    valor: parseFloat(valor),
    tipo,
  };

  aoAdicionar(novoGasto);

  setDescricao("");
  setValor("");
  setTipo("Receita");
}


ğŸ“Œ O que ela fazia:
. Impedia o reload do formulÃ¡rio (event.preventDefault()).
. Criava um novo objeto gasto.
. Chamava a funÃ§Ã£o aoAdicionar.
. Limpava os campos do formulÃ¡rio.

âš ï¸ LimitaÃ§Ã£o: sÃ³ servia para adicionar. NÃ£o sabia lidar com ediÃ§Ã£o.



2. Quando surgiu a funÃ§Ã£o salvarGasto:
. Depois, adicionamos a funcionalidade de editar gastos existentes.
. Agora o formulÃ¡rio precisa ser mais inteligente:
  . Se nÃ£o houver gasto em ediÃ§Ã£o â†’ criar um novo.
  . Se houver gasto em ediÃ§Ã£o â†’ atualizar o gasto existente.

function salvarGasto(evento) {
  evento.preventDefault();

  const gastoAtualizado = {
    id: gastoSelecionado ? gastoSelecionado.id : Date.now(),
    descricao,
    valor: parseFloat(valor),
    tipo,
  };

  aoGerenciar(gastoAtualizado);

  setDescricao("");
  setValor("");
  setTipo("Receita");
}


ğŸ“Œ O que ela faz:
. Impede o reload do formulÃ¡rio (evento.preventDefault()).
. Cria um objeto gasto:
  . Se tem gastoSelecionado â†’ usa o mesmo id (ediÃ§Ã£o).
  . Se nÃ£o tem â†’ gera um novo id (adiÃ§Ã£o).
. Chama aoGerenciar, que decide se vai adicionar ou atualizar.
. Limpa os campos do formulÃ¡rio.

âœ… Vantagem: cobre os dois cenÃ¡rios (adiÃ§Ã£o e ediÃ§Ã£o).




3. Por que precisamos sÃ³ de uma funÃ§Ã£o agora:
. aoEnviarFormulario â†’ sÃ³ servia para adicionar, deixou de ser Ãºtil quando introduzimos ediÃ§Ã£o.
. salvarGasto â†’ Ã© mais completa, cobre os dois cenÃ¡rios.

Se mantivÃ©ssemos as duas:
. TerÃ­amos cÃ³digo duplicado.
. CorrÃ­amos risco de confundir qual usar no onSubmit.
. O cÃ³digo ficaria menos limpo e mais difÃ­cil de manter.

ğŸ“Œ ConclusÃ£o
. No comeÃ§o, fazia sentido ter aoEnviarFormulario porque o app sÃ³ adicionava.
. Quando passamos a ter ediÃ§Ã£o, o fluxo de adicionar e editar pÃ´de ser unificado numa sÃ³ funÃ§Ã£o.
. salvarGasto substitui aoEnviarFormulario e Ã© suficiente para o formulÃ¡rio, mantendo o cÃ³digo mais limpo, claro e escalÃ¡vel.









































modificaÃ§Ãµes feitas: 17:20 do 17/09/2025:

3) CRUD â€” como o fluxo de ediÃ§Ã£o funciona agora (linha por linha)

1. Adicionar:
. O FormularioGasto cria um objeto gasto (com id, descricao, valor, tipo) e chama aoGerenciar(gasto).
. gerenciarGasto detecta que nÃ£o hÃ¡ gastoSelecionado e faz setGastos([...gastos, gasto]).
. Chama mostrarAlerta(..., "success").

2. Editar:
. O botÃ£o editar na lista chama aoEditar(id) (prop ligada a abrirEdicao).
. abrirEdicao encontra o gasto e setGastoSelecionado(gasto).
. O FormularioGasto (com useEffect) prÃ©-preenche os inputs com gastoSelecionado.
. Ao submeter o formulÃ¡rio, aoGerenciar Ã© chamado com o objeto atualizado (mesmo id).
. gerenciarGasto detecta que hÃ¡ gastoSelecionado e substitui o item no array (map).
. Limpa gastoSelecionado (setGastoSelecionado(null)) para voltar ao modo "adicionar".
. Chama mostrarAlerta(..., "warning").

Remover:
. removerGasto(id) cria nova lista via filter e faz setGastos(novaLista).
. Chama mostrarAlerta(..., "danger").



4) Alerta â€” agora um objeto com mensagem e tipo
Antes vocÃª guardava uma string; agora o estado alerta mantÃ©m um objeto:
{ mensagem: "Gasto adicionado", tipo: "success" }


Vantagens:
. tipo mapeia diretamente para classes Bootstrap (alert-success, alert-danger), entÃ£o estilo e lÃ³gica ficam juntos.
. FÃ¡cil de estender (p.ex. duracao, acao).

Timeout seguro:
. Uso de timeoutRef para evitar acÃºmulo de timeouts quando o usuÃ¡rio dispara alertas rÃ¡pidos.
. Ao criar novo alerta limpamos timeoutRef.current antigo, e entÃ£o setamos um novo setTimeout.
. HÃ¡ tambÃ©m cleanup no useEffect para limpar timeout se o componente desmontar.
. Isso evita comportamento estranho (alertas que somem depois de tempos antigos) e evita vazamento de timers.


-->